(ns cravendb.scratch
  "The sole purpose of this file is to act as a place to play with stuff in repl"
  (:require [cravendb.indexing :as indexing]
            [cravendb.documents :as docs]
            [cravendb.client :as client]
            [cravendb.query :as query]
            [cravendb.indexstore :as indexes]
            [cravendb.queryparsing :as qp]
            [cravendb.indexengine :as indexengine]
            [cravendb.storage :as storage]
            [cravendb.storage :as s]
            [me.raynes.fs :as fs]
            [ring.adapter.jetty :refer [run-jetty]]
            [cravendb.http :as http]  
            [cravendb.lucene :as lucene]
            [instaparse.core :as insta])
  (:use [cravendb.testing]
       [cravendb.core]
       [clojure.tools.logging :only (info debug error)] 
       [clojure.pprint]
       [cravendb.querylanguage]
        )
  (:import 
           (org.apache.lucene.analysis.standard StandardAnalyzer)
           (org.apache.lucene.store FSDirectory)
           (org.apache.lucene.store RAMDirectory)
           (org.apache.lucene.util Version)
           (org.apache.lucene.index IndexWriterConfig)
           (org.apache.lucene.index IndexWriter)
           (org.apache.lucene.index DirectoryReader)
           (org.apache.lucene.index Term)
           (org.apache.lucene.search IndexSearcher)
           (org.apache.lucene.search Sort)
           (org.apache.lucene.search SortField)
           (org.apache.lucene.search SortField$Type)
           (org.apache.lucene.search NumericRangeQuery)
           (org.apache.lucene.search TermQuery)
           (org.apache.lucene.queryparser.classic QueryParser)
           (org.apache.lucene.document Document)
           (org.apache.lucene.document Field)
           (org.apache.lucene.document Field$Store)
           (org.apache.lucene.document Field$Index)
           (org.apache.lucene.document TextField)
           (org.apache.lucene.document StringField)
           (org.apache.lucene.document IntField)
           (org.apache.lucene.document FloatField)
           (java.util Collection Random)
           (java.io File File PushbackReader IOException FileNotFoundException )))


;; Okay, so we want an indexing queue
;; The indexing queue has the "last etag seen" held
;; The indexing queue can be told about new etags
;; The indexing queue will hold the last etag indexed
;; The indexing queue will reset the last indexed etag if told about an earlier etag
;;
;; I think there should be a document database interface which wraps all the other interfaces
;; It should be coordinating activity between the different storage/engines

;; Etags should be time based (uuid v1?)
;; The writing of the last seen etag should be managed by the outside of this process
;; Document storage should be told about the etag of the document during storage process
;; This should be generated by the outside
;; Document storage should only be storing documents
;; Document storage should be providing iteration over documents
;;  - By e-tag
;;  - By prefix
;;

;; Steps to re-factor therefore
;; - Move tests and external use to use a new 'database' object
;; - The database object is a map of { storage last-etag etc }
;; - It has all the methods for 
;; - Storing documents
;; - Storing indexes
;;
;; It is used directly by a client or exposed via HTTP



(defn read-last-seed [db]
  (with-open [iter (s/get-iterator db)]
    (.seekToLast iter )
    (Integer/parseInt 
      (or (:k (first (map expand-iterator-str (iterator-seq iter)))) "0"))))

(defn create-queue [db seed]
  {
   :seed (atom (read-last-seed db))
   :db db
   :deleted ()
   })

(defn write-to-queue! 
  [q & values]
  (with-open [tx (s/ensure-transaction (:db q))]
    (s/commit! 
      (reduce #(s/store %1 
        (format "%030d" (swap! (:seed q) inc)) %2) tx values))))

(defn delete-from-queue! [q & ids]
  (with-open [tx (s/ensure-transaction (:db q))] 
    (s/commit! (reduce #(s/delete %1 %2) tx #spy/p ids))))

(defn get-iterator [q]
  (let [iter (s/get-iterator (:db q))]
    (.seekToFirst iter)
    iter))

#_ (def db (s/create-storage "testqueue"))
#_ (do
     (.close db)
     (fs/delete-dir "testqueue"))

#_ (def queue (create-queue db 0))
#_ (write-to-queue! queue (pr-str {"something" "something"}))

#_ (with-open [iter (get-iterator queue)]
     (doall (map expand-iterator-str (iterator-seq iter))))

#_ (with-open [iter (get-iterator queue)]
     (apply delete-from-queue! queue 
        (map :k (map expand-iterator-str (iterator-seq iter)))))

#_ (delete-from-queue! queue 2 4 6 7)

